# Counter: a simple widget

![Counter](screenshots/counter.png)

Graphical User Interfaces have two main concerns:

1.  Presenting information visually
2.  Handling user input

[The code for this example can be found here](https://github.com/kas-gui/tutorials/blob/master/examples/counter.rs). Lets dive in.

## Dependencies

```rust
use kas::prelude::*;
use kas::widgets::{Label, TextButton};
```
The [`kas::prelude`] includes a bunch of commonly-used, faily unambiguous stuff.
Besides that, we only use a couple of widgets.

### Logging

```
env_logger::init();
```
KAS uses the [`log`](https://crates.io/crates/log) facade internally. To see the
output, we need an implementation, such as
[`env_logger`](https://crates.io/crates/env_logger).

Trace level can be a bit chatty; to get a *reasonable* level of output you might
try this:
```sh
export RUST_LOG=warn,naga=error,kas=debug
cargo run --example counter
```

## Defining Counter with the help of macros

```rust
#use kas::prelude::*;
#use kas::widgets::{Label, TextButton};
impl_scope! {
    #[widget{
        layout = column: [
            align(center): self.display,
            row: [
                TextButton::new_msg("−", Increment(-1)),
                TextButton::new_msg("+", Increment(1)),
            ],
        ];
    }]
    #[derive(Debug)]
    struct Counter {
        core: widget_core!(),
        #[widget]
        display: Label<String>,
        count: i32,
    }
}
```

### Macros

What is this [`impl_scope!`](https://docs.rs/impl-tools/latest/impl_tools/macro.impl_scope.html)? It's a proc-macro which:

-   encompasses a type (enum/struct/type alias/union) and `impl` blocks
-   provides `impl Self` syntax (`Self` expands to the type name, correctly
    handling generic parameters and bounds)
-   supports attribute macros with slightly non-standard behaviour

And the `#[widget]` attribute macro? This occurs twice above, with completely
different applications:

1.  `#[widget { layout = .. ; }]` is used on `struct Counter` to implement the
    [`Widget`] trait.
    You could think of it as `#[derive(Widget)]`, but it differs in several
    ways from typical "derive" macros:

    -   It supports parameters, such as `layout = .. ;` used here
    -   It implements multiple traits ([`Widget`] is a "trait family")
    -   You can still write an `impl Widget for Counter { .. }` ...
    -   ... which the `#[widget]` macro can see and modify, thanks to the enclosing
        `impl_scope!`. Essentially, the macro provides default impls for all
        [`Widget`] methods while letting you replace the impl of any method you
        wish to.
2.  `#[widget] display: Label<String>` marks this field as a child widget.

One other macro appears above: `core: widget_core!(),`. Every widget must have
a field with this `widget_core!()` type. All you really need to know about it is
that it supports [`Default`] and that it's generated by the outer `#[widget]`
macro. Oh, and it either looks like the [`CoreData`] type or it at least has the
same `rect: Rect` and `id: WidgetId` fields; directly accessing these fields is
considered valid.

### Constructor and layout

```rust
#use kas::prelude::*;
#use kas::widgets::{Label, TextButton};
impl_scope! {
    #[widget{
        layout = column: [
            align(center): self.display,
            row: [
                TextButton::new_msg("−", Increment(-1)),
                TextButton::new_msg("+", Increment(1)),
            ],
        ];
    }]
    struct Counter {
        core: widget_core!(),
        #[widget]
        display: Label<String>,
        count: i32,
    }

    impl Self {
        fn new(count: i32) -> Self {
            Counter {
                core: Default::default(),
                display: Label::from(count.to_string()),
                count,
            }
        }
    }
};
```

First note the simple constructor: `fn Counter::new`. (Reminder: `impl Self`
is expanded to `impl Counter` by the `impl_scope!` macro.)

Our widget's layout is here defined by the `layout =` parameter.
(An alternative is to implement [`Layout`] directly.)
The `layout` syntax is new, but should be easy to understand:

-   Our top layout is a `column` containing ...
-   ... the field `self.display`, annotated with `align(center)` ...
-   ... and a `row` of two [`TextButton`] widgets

In general, layout syntax is one of four things:

-   a keyword such as `column` or `align(..)`, followed by a `:` and some
    sub-layout (or list of sub-layouts)
-   `self.foo` where `foo` is a field
-   `Foo::new(..)` where `Foo` is a type name (starting upper-case), the type is
    a [`Widget`], and the whole expression `Foo::new(..)` constructs an object
    which coerces to `dyn Widget`
-   `"blah blah"` — a simple label

It's a *bit* more complex than this, but that should get you started. You can
read the reference here: [`kas::macros::widget`].

Aside: since KAS is a *stateful* UI system, the [`TextButton`] widgets in our
row must be stored *somewhere*, right? Yes: in the `widget_core!`
This is why the field has a macro-defined type.

## Messages

### The message type

We skipped this type definition above:
```rust
#[derive(Clone, Debug)]
struct Increment(i32);
```
A simple tuple struct, used for our button messages. The `Debug` implementation
is required to send as a message; `Clone` is needed for the `new_msg` method.

Aside: we could simply use `i32` and forget the `Increment` type, but using a
named type provides useful documentation, especially in log messages.

### The message stack

Our button widgets are constructed as e.g. `TextButton::new_msg("+", Increment(1))`.
Referring to the [`TextButton`] documentation (or the source) we see that
this is equivalent to `TextButton::new("+").on_push(|mgr| mgr.push_msg(Increment(1)))`,
using the method [`EventMgr::push_msg`], which pushes to the "message stack".

Event handling in KAS occurs roughly as follows:

1.  Translate a [`winit::event::WindowEvent`] to a [`kas::event::Event`]
2.  Locate the target's [`WidgetId`], either via use of the mouse cursor (or
    touch event) coordinates (see [`Layout::find_id`]) or via keyboard
    navigation (see [`ConfigMgr::next_nav_focus`])
3.  Call [`EventMgr::send`] on the root widget (the window), which recursively
    passes the message down to the target `id: WidgetId`
4.  Call [`Widget::handle_event`] on the target widget ([`TextButton`] may call
    [`EventMgr::push_msg`] here, depending on the event)
5.  Unpack the recursion of step (3) to head back to the root, calling
    [`Widget::handle_message`] on *each* parent until the message stack is empty

### Handling messages

Notice something? Our `Counter` widget is a parent of our [`TextButton`] widgets, so
we just need to implement `handle_message` to interpret our `Increment` message:
```rust
#use kas::prelude::*;
#use kas::widgets::{Label, TextButton};
impl_scope! {
    #[widget{
        // layout = ..;
    }]
    struct Counter {
        core: widget_core!(),
        #[widget]
        display: Label<String>,
        count: i32,
    }
    impl Widget for Self {
        fn handle_message(&mut self, mgr: &mut EventMgr, _: usize) {
            if let Some(Increment(incr)) = mgr.try_pop_msg() {
                self.count += incr;
                *mgr |= self.display.set_string(self.count.to_string());
            }
        }
    }
};
```
[`EventMgr::try_pop_msg`] lets us read the message from the stack. We use the
payload `incr` to update `self.count`, then update `self.display`.

The method [`HasString::set_string`] returns a [`TkAction`], which we feed into
the [`EventMgr`] via `*mgr |= action` (in this case, notifying that a redraw is
required).

Aside: what if we forgot to write our `handle_message` implementation and left
the message on the stack? Assuming you have a logger enabled, you'd see
something like this:
```sh
[2022-08-20T14:33:47Z DEBUG kas_core::event::manager::messages] push_msg: counter::main::Increment::Increment(1)
[2022-08-20T14:33:47Z WARN  kas_core::event::manager::messages] unhandled: counter::main::Increment::Increment(1)
```
Now perhaps you see why we defined our `Increment` type and didn't simply push an `i32`!

[`Default`]: https://doc.rust-lang.org/nightly/std/default/trait.Default.html
[`Widget`]: https://docs.rs/kas/latest/kas/trait.Widget.html
[`Layout`]: https://docs.rs/kas/latest/kas/trait.Layout.html
